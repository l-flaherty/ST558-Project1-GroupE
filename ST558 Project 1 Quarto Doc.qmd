---
title: "ST558 Project 1"
author: "Flaherty and Lu"
format: html
editor: visual
---

## Data Processing

We are interested in various types of census data, and aim to create functions that return visuals of said data from inputs of either urls or csv files. To start, we look at a single file before generalizing.

The file was made available at <https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv>, where We download it locally and then loaded it into our R session. Since we are using R projects, and since we saved the download in the working directory for the project, we don't need to worry about specifying file paths. To start our analysis, we installed any packages we might need with `install.packages`, and call them here with `library()`.

```{r, results='hide'}
library(tidyverse)            
library(readxl)


census=read_csv("EDU01a.csv")       
```

### Initial Data Exploration
To get an initial glance at the data, we try normal summary functions. Since the output of these functions is so long, we admit it here. What is clear from the output is that without additional context for what the variables mean, the file contents would be very confusing.

```{r, results='hide'}
str(census)
summary(census)
```

Luckily we are given some of this information. The file contains census data from 2010, with distinct areas in each row, and census surveys in each column. The census surveys follow a code: the first three characters give the survey type (for example **AGE** in the `AGE010180D` code refers to age, while **EDU** in the  `EDU640180D` code refers to education), the next four give the type of value from the survey (for example **6401** in the `EDU640180D` code refers to years of school complete, while **0101** in the `EDU010189D` code refers to public school enrollment), and the next two give the year (for example the **89** in the `EDU010189D` code refers to 1989). There is no data from before 1910. 


### Data Manipulation And Wrangling
#### Select, Reshape, And Rename

As is, the data is not in a great format for analysis. We want to filter down the data to just the columns we actually care about, and to put it in long format. That is, instead of a distinct area in each row with many different census types in the columns, we want to have just one record for each row, with an additional column added for the census code.

To choose the columns we want, ew use the `select()` function from the `tidyverse`. To keep our naming conventions consistent, we also want to `rename()` certain columns. Additionally, we want to transform our data structure so that the columns holding count data are put in a single column, and the data from those columns put in a new column called `observed`. We can do so with the `pivot_longer()` function. Putting all these steps together with the natural chaining operation `|>`, we can overwrite our object as follows: 

```{r}
census=census |>                   
  select(Area_name, STCOU, ends_with("D")) |>
  rename(area_name=Area_name) |>
  pivot_longer(cols=ends_with("D"),
               names_to="code",    
               values_to="observed")
```

#### Break Apart Census Code
In general, we want the smallest piece of data stored in it's own column. Specific to this file, the census code encodes a lot of information which we'd like to break up so that we can more easily filter it in the future. 

One way to do so is to extract the year from which the survey was conducted on, and store the year and census type in their own columns. Note that direct inspection on a csv file giving information on the variables, namely using ``=SORT(UNIQUE(RIGHT(range_of_cells, 4)))`, showed that no data existed prior to 1910-- any two-digit code less than 10 will be from the 2000s.

Since we are in the `tidyverse` already, it makes sense to utilize the `stringr` package to deal with these strings. Within that packages, `str_sub` extracts parts of a string. Since we know the first 7 characters of our string give the survey type, we can directly extract those to form a new column. Since we know the next two characters of our string give the year, we can append the relevant first two digits to make a year. We have already explained that no data prior to 1910 exists, so know that any data with a year value under 10 will be from the 2000s. 

```{r, output=FALSE}
survey_type=str_sub(census$code, start=1, end=7)

yy=as.numeric(str_sub(census$code, start=8, end=9))
range(yy)                          #87-96 so all from 90s here, but want to make robust#  
survey_year=as.numeric(ifelse(yy<=10,                        
                              paste0("200", yy),
                              paste0("19", yy)))

census=census |>
  mutate(survey_type=survey_type, survey_year=survey_year) |>
  select(area_name, STCOU, survey_type, survey_year, observed)

rm(yy, survey_type, survey_year)                             #no need to keep#
```
#### Break Into County Vs. Non-County Data    

In keeping with the above, we'd like to get more granular into our data, specifying the county name when available. To do so, we again rely on the `stringr` package and perform similar operations to the above. 

We first get a sense of the naming patters in our `area_name` column.

```{r}
unique(census$area_name)[1:10]
```

Notice that commas exist in areas which have the county specified (like "Autauga, AL"), but there are no commas in areas without county-level data (like "ALABAMA"). We can split our existing `census` tibble into two different tibbles, one with county-level data and one without, by searching for the rows in the tibble which have a comma. The `str_locate()` function in the `stringr` package does the trick, taking in our vector of `area_name`'s, searching for the comma, and returning a matrix giving the starting and ending character of where the comma exists. Since a comma is only one character, we only need one of these columns, and so return just the first column from our matrix. 

```{r}
a=str_locate(census$area_name, ",")[,1]            #dummy object, no commas in non-county#
noncounty=census[which(is.na(a)),]                 #keep non-county data together#
county=census[which(!is.na(a)),]                   #keep county data together#
rm(a)                                              #no need to keep#
```

We can double check that this split worked as expected with `unique` from base R.

```{r}
unique(noncounty$area_name)                        
unique(county$area_name)[1:50]
```

After verifying that the split worked as intentioned, we add a class to each tibble, overwriting the previous one.

```{r}
class(county)=c("county", class(county))           
class(noncounty)=c("state", class(noncounty))      
```

#### Classifying States And Divisions
With the distinct tables now in hand, we want to break up the `area_name` to both the county and state in the case of the `county` data, and to include the division in the case of the `noncounty` data. 

In the `county` data, we are just extracting the last two characters of the string for the state abbreviation, and all parts of the string less the last four for the county (two for the state abbreviation, one for the space, one for the comma). We can do this succinctly with the same `str_sub` function, utilizing the `nchar` function in the process (which logically returns the number of characters a string has).

```{r}
county=county |>
  mutate(state=str_sub(area_name, nchar(county$area_name) - 1, nchar(county$area_name)),
         district=str_sub(area_name, 1, nchar(county$area_name)-4)) |>
  select(-area_name) |>
  select(state, district, everything())
```
