---
title: "ST558 Project 1"
author: "Flaherty and Lu"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# This is a development branch from Jia Lu.

## Data Processing

### First steps

1. Read in data, select only columns (Area_name, STCOU, any colum that ends in "D"), and rename column Area_name as area_name.

```{r}
library(tidyverse)
edu01a_data <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv") |> 
  select(Area_name, STCOU, ends_with("D")) |>
  rename("area_name" = "Area_name")
edu01a_data
```

2. Convert the data into long format where each row has only one enrollment value for that area_name.

```{r}
edu01a_data <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv") |> 
  select(Area_name, STCOU, ends_with("D")) |>
  rename("area_name" = "Area_name") |> 
  pivot_longer(cols = is.numeric,
               names_to = "enrollment",
               values_to = "value")
edu01a_data
```

3. Parse the string from the "Enrollment" column to pull out the year, and convert the year into a numeric value. Grab the first three characters and following four digits to create a new variable.

```{r}
edu01a_data <- edu01a_data |> 
  mutate(measurement = substr(enrollment, 1, 7)) |> 
  mutate(year = substr(enrollment, 8, 9))

edu01a_data$year <- year(parse_date_time(edu01a_data$year, "y"))
edu01a_data
```

4. Creating two data sets:
- One data set that contains only non-county data. Add a class to the tibble called state.
- One data set that contains only county level data. Add a class to the tibble called county

```{r}
county_index <- grep(pattern = ", \\w\\w", edu01a_data$area_name)

county_data <- edu01a_data[county_index,]
county_data
class(county_data) <- c("county", class(county_data))
class(county_data)

non_county_data <- edu01a_data[- county_index,]
non_county_data
class(non_county_data) <- c("state", class(non_county_data))
class(non_county_data)
```

5. For the county level tibble, create a new variable that describes which state one of these county measurements corresponds to (the two digit abbreviation).

```{r}
county_data <- county_data |> 
  mutate(state = substr(county_data$area_name, nchar(county_data$area_name) - 1, nchar(county_data$area_name)))
county_data
```

6. For the non-county level tibble, create a new variable called “division” corresponding to the state’s classification of division here. If row corresponds to a non-state (i.e. UNITED STATES), return ERROR for the division.

```{r}
non_county_data <- non_county_data |>
  mutate(division = ifelse(non_county_data$area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT"),"Division 1", 
                           ifelse(non_county_data$area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), "Division 2", 
                                  ifelse(non_county_data$area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"), "Division 3",
                                         ifelse(non_county_data$area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA"), "Division 4",
                                                ifelse(non_county_data$area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "District of Columbia", "WEST VIRGINIA"), "Division 5",
                                                       ifelse(non_county_data$area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"), "Division 6",
                                                              ifelse(non_county_data$area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS"), "Division 7",
                                                                     ifelse(non_county_data$area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"), "Division 8",
                                                                            ifelse(non_county_data$area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON"), "Division 9",
                                                                                   "ERROR"))))))))))
non_county_data
```

## Creating functions.

- Write one function that does steps 1 & 2 above. Give an optional argument that allows the user to specify the name of the column representing the value (enrollment for these data sets).

```{r}
function_for_step_1_2 <- function(url, default_var_name = "value") {
  tmp <- read_csv(url) |>
    select(Area_name, STCOU, ends_with("D")) |>
    rename("area_name" = "Area_name") |>   
    pivot_longer(cols = is.numeric,
                 names_to = "enrollment",
                 values_to = default_var_name)
  return(tmp)
}
```

- Write another function that takes in the output of step 2 and does step 3 above.

```{r}
function_for_step_3 <- function(tmp) {
  tmp <- tmp |> 
    mutate(measurement = substr(enrollment, 1, 7)) |>
    mutate(year = substr(enrollment, 8, 9))
  
  tmp$year <- year(parse_date_time(tmp$year, "y"))
  return(tmp)
}
```

- Write a function to do step 5.

```{r}
function_for_step_5 <- function(county_data) {
  county_data <- county_data |> 
    mutate(state = substr(county_data$area_name, nchar(county_data$area_name) - 1, nchar(county_data$area_name)))
  return(county_data)
}
```

- Write a function to do step 6.

```{r}
function_for_step_6 <- function(non_county_data) {
  non_county_data <- non_county_data |>
    mutate(division = ifelse(non_county_data$area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT"),"Division 1", 
                             ifelse(non_county_data$area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), "Division 2", 
                                    ifelse(non_county_data$area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"), "Division 3",
                                           ifelse(non_county_data$area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA"), "Division 4",
                                                  ifelse(non_county_data$area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "District of Columbia", "WEST VIRGINIA"), "Division 5",
                                                         ifelse(non_county_data$area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"), "Division 6",
                                                                ifelse(non_county_data$area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS"), "Division 7",
                                                                       ifelse(non_county_data$area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"), "Division 8",
                                                                              ifelse(non_county_data$area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON"), "Division 9",
                                                                                     "ERROR"))))))))))
  return(non_county_data)
}
```

- Write another function that takes in the output from step 3 and creates the two tibbles in step 4, calls the above two functions (to perform steps 5 and 6), and returns two final tibbles.

```{r}
function_for_steps4_5_6 <- function(tmp) {
  county_index <- grep(pattern = ", \\w\\w", tmp$area_name)
  county_data <- tmp[county_index,]
  class(county_data) <- c("county", class(county_data))
  non_county_data <- tmp[- county_index,]
  class(non_county_data) <- c("state", class(non_county_data))
  county_data <- county_data |> function_for_step_5 ()
  non_county_data <- non_county_data |> function_for_step_6 ()
  return(list(county_data, non_county_data))
} 
```

- Creating a wrapper function that takes in the URL of a .csv file in this format and the optional argument for the variable name, calls the functions you wrote above, and then returns the two tibbles.

```{r}
my_wrapper <- function(url, default_var_name = "value") {
  result <- function_for_step_1_2(url, default_var_name) |>
    function_for_step_3() |>
    function_for_steps4_5_6 ()
  return(result)
}

my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
```

