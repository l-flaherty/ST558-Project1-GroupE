---
title: "ST558 Project 1"
author: "Flaherty and Lu"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# This is a development branch from Jia Lu.

## Data Processing

### First steps

1.  Read in data, select only columns (Area_name, STCOU, any colum that ends in "D"), and rename column Area_name as area_name.

```{r}
library(tidyverse)

#read in csv data from URL
edu01a_data <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv") |> 
  select(Area_name, STCOU, ends_with("D")) |>
  rename("area_name" = "Area_name")

edu01a_data
```

2.  Convert the data into long format where each row has only one enrollment value for that area_name.

```{r}
#manipulating data as required above
edu01a_data <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv") |> 
  select(Area_name, STCOU, ends_with("D")) |>
  rename("area_name" = "Area_name") |> 
  pivot_longer(cols = is.numeric,
               names_to = "enrollment",
               values_to = "value")

edu01a_data
```

3.  Parse the string from the "Enrollment" column to pull out the year, and convert the year into a numeric value. Grab the first three characters and following four digits to create a new variable.

```{r}
#creating new variables as required above
edu01a_data <- edu01a_data |> 
  mutate(measurement = substr(enrollment, 1, 7)) |> 
  mutate(year = substr(enrollment, 8, 9))

edu01a_data$year <- year(parse_date_time(edu01a_data$year, "y"))
edu01a_data
```

4.  Creating two data sets:

-   One data set that contains only non-county data. Add a class to the tibble called state.
-   One data set that contains only county level data. Add a class to the tibble called county

```{r}
#get index to reference selecting rows
county_index <- grep(pattern = ", \\w\\w", edu01a_data$area_name)

#subsetting data to get county level data
county_data <- edu01a_data[county_index,]
county_data

class(county_data) <- c("county", class(county_data))
class(county_data)

#subsetting data to get non-county level data
non_county_data <- edu01a_data[- county_index,]
non_county_data

class(non_county_data) <- c("state", class(non_county_data))
class(non_county_data)
```

5.  For the county level tibble, create a new variable that describes which state one of these county measurements corresponds to (the two digit abbreviation).

```{r}
#get the last two characters from area_name
county_data <- county_data |> 
  mutate(state = substr(county_data$area_name, nchar(county_data$area_name) - 1, nchar(county_data$area_name)))

county_data
```

6.  For the non-county level tibble, create a new variable called “division” corresponding to the state’s classification of division here. If row corresponds to a non-state (i.e. UNITED STATES), return ERROR for the division.

```{r}
#use ifelse() to group counties together into each corresponding division
non_county_data <- non_county_data |>
  mutate(division = ifelse(non_county_data$area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT"),"Division 1", 
                           ifelse(non_county_data$area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), "Division 2", 
                                  ifelse(non_county_data$area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"), "Division 3",
                                         ifelse(non_county_data$area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA"), "Division 4",
                                                ifelse(non_county_data$area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "District of Columbia", "WEST VIRGINIA"), "Division 5",
                                                       ifelse(non_county_data$area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"), "Division 6",
                                                              ifelse(non_county_data$area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS"), "Division 7",
                                                                     ifelse(non_county_data$area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"), "Division 8",
                                                                            ifelse(non_county_data$area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON"), "Division 9",
                                                                                   "ERROR"))))))))))

non_county_data
```

## Creating functions.

-   Write one function that does steps 1 & 2 above. Give an optional argument that allows the user to specify the name of the column representing the value (enrollment for these data sets).

```{r}
#create a function to read in csv data and reshaping data from wide to long
function_for_step_1_2 <- function(url, what_var_name = "value") {
  tmp <- read_csv(url) |>
    select(Area_name, STCOU, ends_with("D")) |>
    rename("area_name" = "Area_name") |>   
    pivot_longer(cols = is.numeric,
                 names_to = "enrollment",
                 values_to = what_var_name)
  return(tmp)
}
```

-   Write another function that takes in the output of step 2 and does step 3 above.

```{r}
#create a function to add new variables and convert strings to date
function_for_step_3 <- function(tmp) {
  tmp <- tmp |> 
    mutate(measurement = substr(enrollment, 1, 7)) |>
    mutate(year = substr(enrollment, 8, 9))
  
  tmp$year <- year(parse_date_time(tmp$year, "y"))
  return(tmp)
}
```

-   Write a function to do step 5.

```{r}
#create a function to grab the abbreviation names of states from column area_name
function_for_step_5 <- function(county_data) {
  county_data <- county_data |> 
    mutate(state = substr(county_data$area_name, nchar(county_data$area_name) - 1, nchar(county_data$area_name)))
  return(county_data)
}
```

-   Write a function to do step 6.

```{r}
#create a function to group counties together into corresponding divisions
function_for_step_6 <- function(non_county_data) {
  non_county_data <- non_county_data |>
    mutate(division = ifelse(non_county_data$area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT"),"Division 1", 
                             ifelse(non_county_data$area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), "Division 2", 
                                    ifelse(non_county_data$area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"), "Division 3",
                                           ifelse(non_county_data$area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA"), "Division 4",
                                                  ifelse(non_county_data$area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "District of Columbia", "WEST VIRGINIA"), "Division 5",
                                                         ifelse(non_county_data$area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"), "Division 6",
                                                                ifelse(non_county_data$area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS"), "Division 7",
                                                                       ifelse(non_county_data$area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"), "Division 8",
                                                                              ifelse(non_county_data$area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON"), "Division 9",
                                                                                     "ERROR"))))))))))
  return(non_county_data)
}
```

-   Write another function that takes in the output from step 3 and creates the two tibbles in step 4, calls the above two functions (to perform steps 5 and 6), and returns two final tibbles.

```{r}
#create a function to do multiple things as required above
function_for_steps4_5_6 <- function(tmp) {
  county_index <- grep(pattern = ", \\w\\w", tmp$area_name)
  county_data <- tmp[county_index,]
  class(county_data) <- c("county", class(county_data))
  
  non_county_data <- tmp[- county_index,]
  class(non_county_data) <- c("state", class(non_county_data))
  
  county_data <- county_data |> function_for_step_5 ()
  non_county_data <- non_county_data |> function_for_step_6 ()
  
  return(list(county_data, non_county_data))
} 
```

-   Creating a wrapper function that takes in the URL of a .csv file in this format and the optional argument for the variable name, calls the functions you wrote above, and then returns the two tibbles.

```{r}
#create a wrapper function that perform all the tasks together as required above
my_wrapper <- function(url, what_var_name = "value") {
  result <- function_for_step_1_2(url, what_var_name) |>
    function_for_step_3() |>
    function_for_steps4_5_6 ()
  
  return(result)
}
```

### Call it and combine data.

-   Call the function two times and parse the two .csv files mentioned so far.

```{r}
edu01a_data_from_wrapper <- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
edu01a_data_from_wrapper

edu01b_data_from_wrapper <-
my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
edu01b_data_from_wrapper
```

-   Write a single short function that takes in the results of two calls to the wrapper function.

```{r}
#create a function to combine data from two datasets
combining_data <- function(tmp_1, tmp_2) {
  county_data_combined <- dplyr::bind_rows(tmp_1[[1]], tmp_2[[1]])
  non_county_data_combined <- dplyr::bind_rows(tmp_1[[2]], tmp_2[[2]])
  
  tmp_3 <- list(county_data_combined, non_county_data_combined)
  
  return(tmp_3)
}

data_combined <- combining_data(edu01a_data_from_wrapper, edu01b_data_from_wrapper)
data_combined
```

## Writing a Generic Function for Summarizing.

### for the non-county level tibble

- Write a function that plots the mean value of the statistic (enrollment for this data set) across the years for each Division. That is, on the x-axis we want the numeric year value, on the y-axis we want the mean of the statistic for each Division and numeric year. Remove observations at the ERROR setting of Division.
- plot the data with year as x-axis and mean enrollment value as y-axis for different divisions

```{r}
#Method 1: using mean(get()) to reference column name as required
plot.state <- function(combined_state_data, what_var_name = "value") {
  
  combined_state_data <- combined_state_data |>
    filter(division != "ERROR") |>
    group_by(division, year) |>
    summarize(mean_value = mean(get(what_var_name)))

  ggplot(combined_state_data, aes(x = year, y = mean_value, color = division)) +
    geom_line() +
    labs(x = "Year",
         y = "Mean Enrollment Value",
         color = "Division",
         title = "Mean Enrollment Value by Year and Division")
}

plot.state(combined_state_data = data_combined[[2]])
```


```{r}
#Method 2: using {{}} to reference column name to reach the same goal
plot.state <- function(combined_state_data, what_var_name = value) {
  combined_state_data <- combined_state_data |>
    filter(division != "ERROR") |>
    group_by(division, year) |>
    summarize(mean_value = mean({{what_var_name}}))

  ggplot(combined_state_data, aes(x = year, y = mean_value, color = division)) +
    geom_line() +
    labs(x = "Year",
         y = "Mean Enrollment Value",
         color = "Division",
         title = "Mean Enrollment Value by Year and Division")
}

plot.state(combined_state_data = data_combined[[2]])
```

### for the county level tibble

- filter the data to only include data from the state specified
- find the overall mean of the statistic (use get(var_name) here as well) for each Area_name and sort those values from largest to smallest if ‘top’ is specified or smallest to largest if ‘bottom’ is specified
- obtain the top or bottom x number of Area_names from the previous step where x is given by the user or the default
- filter the data for this state to only include the Area_name’s from the previous part 
- plot the data with year as x-axis and original enrollment value as y-axis for counties refereed in query

```{r}
#create a function as required above
plot.county <- function(combined_county_data, what_var_name = "value", which_state = "NC",  top_or_bottom = "top", how_many_obs = 5){
  
  if (top_or_bottom == "top") {
    area_name_for_plot <- combined_county_data |>
      filter(state == which_state) |>
      group_by(area_name) |>
      summarize(mean_value = mean(get(what_var_name))) |>
      arrange(desc(mean_value)) |>
      slice(1:how_many_obs) |>
      pull(area_name)
    
    area_name_for_plot
  } else if (top_or_bottom == "bottom") {
    area_name_for_plot <- combined_county_data |>
      filter(state == which_state) |>
      group_by(area_name) |>
      summarize(mean_value = mean(get(what_var_name))) |>
      arrange(mean_value) |>
      slice(1:how_many_obs) |>
      pull(area_name)
    
    area_name_for_plot
  } 

  plot_state <- combined_county_data |>
    filter(area_name %in% area_name_for_plot)
  
  ggplot(plot_state, aes(x = year, y = get(what_var_name), color = area_name)) +
    geom_line() +
    labs(x = "Year",
         y = "Enrollment Value",
         color = "Counties",
         title = "Enrollment Value by Year in Counties Referred")
}

#plot.county(combined_county_data = data_combined[[1]], what_var_name = "value", which_state = "CA",  top_or_bottom = "bottom", how_many_obs = 10)

plot.county(combined_county_data = data_combined[[1]], which_state = "NC")

```

## Put it together

###Read in two datasets

- Run your data processing function on the two enrollment URLs given previously, specifying an appropriate name for the enrollment data column.

```{r}
# Pick a different name "enroll_value" instead of the default value "value" for the name of the enrollment data column
#read in one dataset
edu01a_data_from_wrapper <- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv", what_var_name = "enroll_value")

edu01a_data_from_wrapper

#read in another dataset
edu01b_data_from_wrapper <-
my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv", what_var_name = "enroll_value")

edu01b_data_from_wrapper

```

- Run your data combining function to put these into one object (with two data frames)

```{r}
#combine two datasets
data_combined <- combining_data(edu01a_data_from_wrapper, edu01b_data_from_wrapper)
data_combined
```

- Use the plot function on the state data frame

```{r}
#Use the previously picked different name "enroll_value" to refer to the name of the enrollment data column here
plot.state(combined_state_data = data_combined[[2]], what_var_name = enroll_value)
```

- Use the plot function on the county data frame

```{r}
#Specifying the state to be “NC”, the group being the top, the number looked at being 20
plot.county(combined_county_data = data_combined[[1]], what_var_name = "enroll_value", which_state = "NC", top_or_bottom = "top", how_many_obs = 20)

#Specifying the state to be “SC”, the group being the bottom, the number looked at being 7
plot.county(combined_county_data = data_combined[[1]], what_var_name = "enroll_value", which_state = "SC", top_or_bottom = "bottom", how_many_obs = 7)

#Without specifying anything (defaults used)
plot.county(combined_county_data = data_combined[[1]], what_var_name = "enroll_value")

#Specifying the state to be “PA”, the group being the top, the number looked at being 8
plot.county(combined_county_data = data_combined[[1]], what_var_name = "enroll_value", which_state = "PA", top_or_bottom = "top", how_many_obs = 8)
```

###Read in four datasets

- Run your data processing function on the four data sets with given URLs

```{r}
#Use the default what_var_name ("value") without specifying here
pst01a_data_from_wrapper <- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01a.csv")
pst01a_data_from_wrapper

pst01b_data_from_wrapper <-
my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01b.csv")
pst01b_data_from_wrapper

pst01c_data_from_wrapper <- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01c.csv")
pst01c_data_from_wrapper

pst01d_data_from_wrapper <-
my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01d.csv")
pst01d_data_from_wrapper
```

- Run your data combining function (probably three times) to put these into one object (with two data frames)

```{r}
#Combine datasets from pst01a_data_from_wrapper and pst01b_data_from_wrapper
data_combined_a_b <- combining_data(pst01a_data_from_wrapper, pst01b_data_from_wrapper)
data_combined_a_b

#Combine datasets from pst01c_data_from_wrapper and pst01d_data_from_wrapper
data_combined_c_d <- combining_data(pst01c_data_from_wrapper, pst01d_data_from_wrapper)
data_combined_c_d

#Combine all four datasets together
data_combined <- combining_data(data_combined_a_b, data_combined_c_d)
data_combined
```

- Use the plot function on the state data frame

```{r}
#Use the default what_var_name ("value") without specifying here
plot.state(combined_state_data = data_combined[[2]])
```

- Use the plot function on the county data frame

```{r}
#Specifying the state to be “CA”, the group being the top, the number looked at being 15 with the default what_var_name ("value") 
plot.county(combined_county_data = data_combined[[1]], which_state = "CA", top_or_bottom = "top", how_many_obs = 15)

#Specifying the state to be “TX”, the group being the top, the number looked at being 4 with the default what_var_name ("value") 
plot.county(combined_county_data = data_combined[[1]], which_state = "TX", top_or_bottom = "top", how_many_obs = 4)

#Without specifying anything (defaults used)
plot.county(combined_county_data = data_combined[[1]])

#Specifying the state to be “NY”, the group being the top, the number looked at being 10 with the default what_var_name ("value") 
plot.county(combined_county_data = data_combined[[1]], which_state = "NY", top_or_bottom = "top", how_many_obs = 10)
```

